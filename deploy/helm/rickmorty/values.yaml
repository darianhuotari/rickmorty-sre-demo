# --- Image ---
image:
  repository: rickmorty-sre-demo
  tag: latest
  pullPolicy: IfNotPresent

# Used only when HPA is disabled; keep a sane default.
replicaCount: 2

# --- Service ---
service:
  type: ClusterIP
  port: 8000

# --- Ingress ---
ingress:
  enabled: true
  className: nginx
  annotations: {}
  hosts:
    - host: rickmorty.local
      paths:
        - path: /
          pathType: Prefix
  tls: []  # e.g., - secretName: rickmorty-tls; hosts: [rickmorty.example.com]

  # NGINX rate limiting (per-client IP by default)
  rateLimit:
    rps: 50            # requests per second per client
    burst: 100         # token bucket burst
    noDelay: false     # true => serve bursts immediately; false => pace bursts
    connections: 20    # concurrent connections per client
    #statusCode: 429   # not supported by ingress-nginx
    key: "$binary_remote_addr"  # rate-limit key (e.g., $binary_remote_addr, $http_x_api_key)

# --- Resources (requests are important for HPA) ---
resources:
  limits:
    #cpu: "500m"       # omit CPU limit for latency-sensitive services
    memory: "512Mi"
  requests:
    cpu: "250m"
    memory: "256Mi"

nodeSelector: {}
tolerations: []
affinity: {}

# --- HPA ---
hpa:
  enabled: true
  minReplicas: 2
  maxReplicas: 6
  # Targets are percentages of *requested* resources
  cpuUtilization: 70
  memoryUtilization: 80

# --- App env configuration ---
env:
  PAGE_CACHE_TTL: "30" # In-process page cache TTL in seconds
  CACHE_TTL: "300" # Upstream cache TTL in seconds
  MAX_RETRIES: "5"
  REQUEST_TIMEOUT: "10"
  REFRESH_WORKER_ENABLED: "1" # "1" to enable, "0" to disable
  REFRESH_INTERVAL: "300" # main.py DB refresh task interval in seconds
  LOG_FILE_PATH: "/var/log/app/app.log"  # main container writes; sidecar tails

  # DB wait / startup backoff
  DB_WAIT_MAX_ATTEMPTS: 10
  DB_WAIT_BACKOFF_START: 1.0
  DB_WAIT_BACKOFF_MAX: 10.0

  # SQLAlchemy pool tuning (only used for Postgres URLs)
  DB_POOL_SIZE: 5
  DB_MAX_OVERFLOW: 10
  DB_POOL_RECYCLE: 1800

# --- Database configuration ---
# Pick exactly one path:
# 1) postgresql.enabled: true      -> chart creates <release>-conn and injects it
# 2) database.existingSecret: ""   -> ESO/Vault-produced Secret (recommended for prod)
# 3) database.createSecret: true   -> DEV/DEMO ONLY: create Secret from database.url
database:
  existingSecret: ""          # e.g., "rmdb-secret"
  key: "DATABASE_URL"         # key inside the Secret
  createSecret: false
  url: ""                     # e.g., "postgresql+asyncpg://rick:rickpass@postgres:5432/rmdb"

postgresql:
  enabled: true
  auth:
    username: rick
    password: rickpass        # demo only; do not use in prod
    database: rmdb
  primary:
    persistence:
      enabled: false          # ephemeral for demo; set true with a StorageClass in prod

# --- Fluent Bit log sidecar (tails shared emptyDir, ships to stdout) ---
fluentbit:
  enabled: true
  image: "cr.fluentbit.io/fluent/fluent-bit:2.1.10"
  resources:
    requests:
      cpu: 50m
      memory: 64Mi
    limits:
      cpu: 200m
      memory: 128Mi
  inputPath: "/var/log/app/app.log"

# --- Security contexts ---
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 10001
  runAsGroup: 10001
  fsGroup: 10001
  seccompProfile:
    type: RuntimeDefault

containerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]
